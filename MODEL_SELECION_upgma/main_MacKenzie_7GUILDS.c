/* 
   This code reads MacKenzie generic data file, which structure is:
 
   Species Name  F1 ... Fn t0 t0 t0 t1 t1 t1 t2 t2 t2 ... ... ... tn tn tn
                 -- ... -- -- -- -- -- -- -- -- -- -- --- --- --- -- -- --
       Sp_0      A  ... a  1  0  0  0  0  1  1  1  0  ... ... ... 1  1  0 
       Sp_1      B  ... a  1  0  0  0  0  1  0  0  1  ... ... ... 1  1  0 
        .        .                                                .  .  . 
        .        .                                                .  .  . 
        .        .                                                .  .  . 

   Then, the code fits the simplest stochastic model underlying MacArthur and Wilson 
   IBT (1963) through maximum likelihood by way of grouping rows after a choosen factor. 
   Then, an UPGMA is used to classify groups (p.e. species, Phyla, OUTs, trophic guilds, 
   etc) according to their parameter values. At different levels of similarity on the 
   model parameter space, partitions, so different species groupings, 
   are defined. Each partition defines a different model with a different number of 
   parameters. Finally, Akaike Information Criteria are used for model comparison. 

   In an output file, NLL, AIC, AIC_c, AIC_d differences and AIC_w model weights are 
   organized in a table (each row corresponds to a model corresponding to a different 
   partition, this is, a different distribution of species into groups, and therefore, 
   a model with a different number of parameters). The code creates the file 
   Model_Selection_Results.dat to save these results. The table of results are also 
   saved in latex format. These files are generated by the function: 

   MODEL_SELECTION_UPGMA_MacKENZIE_R_FUNCTION(...) 
   
   which, in turn, calls:

   MODEL_SELECTION_UPGMA_MacKENZIE_DRIVER(...)

   which, in turn, calls two more functions which are in charge of doing all the 
   computationally-intensive work:

   MODEL_SELECTION_UPGMA_MacKENZIE_R_SHLIB(...) 

   and 

   mle_MacKenzie_Uneven_Matrix_R_SHLIB(...)

   Essentially this main code is only written to wrap up the function:

   MODEL_SELECTION_UPGMA_MacKENZIE_R_FUNCTION(...)

   which is intended to be R callable when compiled as a shared object (see makefile).
   
   The Makefile generates the libda_AUX.so shared object, which is a library 
   containg all these functions. 

   The challenge to adapt previous C code into R friendly functions is memmory 
   alignment since R function .C(...) arguments are mandatory pointers to 1D 
   single arrays. Shared objects should be built to match this requirement in order 
   to be called by R through the native R function 
   
   ./C( [NAME_of_th_SHARED_OBJECT].so, arg1, arg2, ...). 
   
   A suitable R function wrapping this call is always recommendable. 

   The following paramaters are passed (as pointers) down to all these auxiliary 
   functions: 
   
   int * No_of_PARAMETERS,  int * No_of_PARAMETERS_MAX,
   int * Index, int * Discretization,
   double * Tolerance, int * No_of_ITERATIONS,
   int * Verbose, int * Minimization, 
   
   which will control different aspects of the underlying the optimization procedure. 

   Compilation:
   
   ~$ make TYPE_of_MAIN=MacKenzie_7GUILDS 

   R shared library compilation. Notice the presence of the Makevars file in 
   compiling directory allows the R native command 'R CMD SHLIB' to 
   locate the whole set of compilation and linking flags correctly:

   make RSH=R_SHLIB shlib_UPGMA

   Execution:

   ~$ ./upgma_model_selection_MacKenzie_7GUILDS -Nr 7 -Nc 28 -pC 1.0 -pE 1.0 -sP 4 -sT 1.0E-08 -m0 0.0 -M0 10.0 -m1 0.0 -M1 10.0

   Some relevant input arguments of the main program are:
   -Nr 15: Number of single data sets (corresponding to different files)
           For instance, differnt islands, different guilds, different
	   species. The initial hypothesis is that every data set
	   is best described by a different colonization-extinction
	   pair. 
   -Nc 17: Number max of columns (sampling times) associated to 
           the data sets (corresponding to different files).  
   -pC 1.0: Colonization initial guess in optimization searches.
   -m0 0.0 -M0 10.0: Min (m0) and Max (M0) parameters values 
                     for bounded optimization serches associated
		     to the first parameter (colonization)
   -pE 1.0: Extinction initial guess in optimization searches.
   -m1 0.0 -M1 10.0: Min (m1) and Max (M1) parameters values 
                     for bounded optimization serches associated
		     to the second parameter (extinction)
   -sP 2: Total Number of model parameters
   -sT 1.0E-08: Accuracy/tolerance value for heuristic optimization 
                searches.
   
   Remember that: 
   
   ~$ ./upgma_model_selection_MacKenzie_3ATOLLS -h 

   will give you full information about model parameters. 

   See also /Include/include.Parameter_Model.argumentControl.c and 
   include.Parameter_Space.argumentControl.c and related include files
   in the /Include/ directory for full information.

   Valgrind execution:

   ~$ valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out.txt ./upgma_model_selection_MacKenzie_7GUILDS -Nr 7 -Nc 28 -pC 1.0 -pE 1.0 -sP 4 -sT 1.0E-08 -m0 0.0 -M0 10.0 -m1 0.0 -M1 10.0
*/
#include <MODEL.h>

#include <IO_Procedures_MacKenzie.h>

#include <IO_Procedures_Standard.h>

#include "global.h"

// #define VERBOSE

#define No_of_ROWS_MAX 500

void MODEL_SELECTION_UPGMA_MacKENZIE_R_FUNCTION( int * pNo_of_SPECIES,
						 char ** Species_Tag, 
						 double * R_Presence,
						 int * No_of_SITES, 
						 double * R_Time_Vector,
						 int * No_of_TIMES, 
						 double * MISSING_VALUE_FLAG, 
						 double * Colonization_Rate,
						 double * C_Range,
						 double * Extinction_Rate,
						 double * E_Range,
						 double * Detectability,
						 double * D_Range, 
						 double * Phi_Time_0,
						 double * P_Range,
						 int * No_of_PARAMETERS,
						 int * No_of_PARAMETERS_MAX,
						 int * Index, 
						 int * Discretization,
						 double * Tolerance, 
						 int * No_of_ITERATIONS,
						 int * Verbose, 
						 int * Minimization,
						 double * R_Results );
void ArgumentControl(int argc, char **argv);

int main(int argc, char **argv)
{
  int i,j,k,l,s,m,n;
  Parameter_Model P;
  char * p;

  #include "default.c"

 /* Command line arguments */
  if(argc>1) ArgumentControl(argc,argv);
  // P_A_R_A_M_E_T_E_R___I_N_I_T_I_A_L_I_Z_A_T_I_O_N ( &P );
  P.No_of_SPECIES       = No_of_SPECIES;
  P.No_of_COLUMNS       = No_of_COLUMNS;
  P.No_of_TRANSECTS     = No_of_COLUMNS;
  P.Colonization_Rate   = Colonization_Rate;     /* Key 0 */
  P.Extinction_Rate     = Extinction_Rate;       /* Key 1 */
  P.Detectability_Value = Detectability_Value;   /* Key 2 */
  P.Phi_0               = Phi_0;                 /* Key 3 */
  P.RATES               = 1;
   /* B E G I N :------------------------------------------------------
     1: Reading 'No_of_SPECIES' single data files. Since data files 
     may be very specific for each system, this part of the code 
     may not be made fully generic, but the output of this reading 
     procedure should result in No_of_SPECIES data matrices containing 
     Presence/Absence data and actual sampling times corresponding to each 
     file once missing values have been excluded. Missig values are 
     labeled with a flag (0.1, see IO_Missing_Value.c). Within a file, 
     sampling times may change from row to row.  
  */
  assert( No_of_SPECIES == 7  ); //-Nr 3 No of files (corresponding to each atoll)
  assert( No_of_COLUMNS == 28 ); //-Nc 28 Total No of Sampling times

  /* Reading three files corresponding to the three atolls */
  int No_of_FILES = No_of_SPECIES; 
  
  char ** Species_Tag = (char **)calloc( No_of_FILES, sizeof(char *) );
  for (i=0; i<No_of_FILES; i++) Species_Tag[i] = (char *)calloc(100, sizeof(char) );
  p = strcat (Species_Tag[0], "Alg");
  p = strcat (Species_Tag[1], "Col");
  p = strcat (Species_Tag[2], "Mac");
  p = strcat (Species_Tag[3], "Mic");
  p = strcat (Species_Tag[4], "Omn");
  p = strcat (Species_Tag[5], "Pis");
  p = strcat (Species_Tag[6], "Zoo");

  char ** File_Tag = (char **)calloc( No_of_FILES, sizeof(char *) );
  for (i=0; i<No_of_FILES; i++) File_Tag[i] = (char *)calloc(100, sizeof(char) );
  for (i=0; i<No_of_FILES; i++) {
    p = strcat (File_Tag[i], Species_Tag[i]);
    p = strcat (File_Tag[i], "_MacKenzie.dat");
  }
  double *** Presence = (double ***)calloc(No_of_FILES, sizeof(double **));
  int * No_of_SAMPLING_TIMES = (int *)calloc(No_of_FILES, sizeof(int) );
  int * TOTAL_No_of_TRANSECTS = (int *)calloc(No_of_FILES, sizeof(int) );
  int * No_of_SITES = (int *)calloc(No_of_FILES, sizeof(int) );
  double ** Time_Vector = (double **)calloc(No_of_FILES, sizeof(double *));
  double ** Time_Vector_Long = (double **)calloc(No_of_FILES, sizeof(double *));
  int    ** Transects   = (int **)calloc(No_of_FILES, sizeof(int *));
  for( i=0; i<No_of_FILES; i++ ){
    No_of_SAMPLING_TIMES[i] = No_of_COLUMNS;
    No_of_SITES[i]          = No_of_ROWS_MAX; 
    Time_Vector[i] = (double *)calloc(No_of_SAMPLING_TIMES[i], sizeof(double));
    Time_Vector_Long[i] = (double *)calloc(No_of_SAMPLING_TIMES[i], sizeof(double));
    Transects[i]   = (int    *)calloc(No_of_SAMPLING_TIMES[i], sizeof(   int));
    
    Presence[i] = (double **)calloc(No_of_SITES[i], sizeof(double *));
    for (j=0; j<No_of_SITES[i]; j++) 
      Presence[i][j] = (double *)calloc(No_of_SAMPLING_TIMES[i], sizeof(double ));
  }

  char ** Species_Name = (char **)calloc( No_of_ROWS_MAX, sizeof(char *) );
  for (i=0; i<No_of_ROWS_MAX; i++) Species_Name[i] = (char *)calloc(100, sizeof(char) );

  for (i=0; i<No_of_FILES; i++)  {
    Reading_MacKenzie_Generic_Matrix_nFactors_from_File( File_Tag[i], 2,
							 Presence[i], Species_Name,
							 &No_of_SITES[i],
							 Time_Vector[i],
							 Transects[i],
							 &No_of_SAMPLING_TIMES[i] );
    // Building Long Vector (with repetitions according the the no of transects)
    n=0; 
    for(j=0; j<No_of_SAMPLING_TIMES[i]; j++)
      for(k=0; k<Transects[i][j]; k++)
	Time_Vector_Long[i][n++] = Time_Vector[i][j];
    TOTAL_No_of_TRANSECTS[i] = n;

    printf(" Atoll %s\t TOTAL No of TRANSECTS = %d\n",
	   Species_Tag[i], TOTAL_No_of_TRANSECTS[i] );
    printf(" No of SAMPLING TIMES = %d\t Time(No of Transects) = {",
	   No_of_SAMPLING_TIMES[i] );
    for(j=0; j<No_of_SAMPLING_TIMES[i]; j++)
      printf(" %g(%d) ", Time_Vector[i][j], Transects[i][j]);
    printf("}\n");

    for(j=0; j<No_of_SITES[i]; j++) {
      m = 0;
      printf(" { "); 
      for(k=0; k<No_of_SAMPLING_TIMES[i]; k++)
	for(n=0; n<Transects[i][k]; n++) printf("%g ", Presence[i][j][m++]);
      printf("}\n"); 
    }
    printf("\n\n");

    // getchar(); 
  }
  
  /* B E G I N : ------------------------------------------------------- 
     1. Transforming C arrys into R friendly arrays */
  int No, NT;
  No  = 0;
  NT  = 0; 
  for(i=0; i<No_of_FILES; i++) { 
    No += No_of_SITES[i] * TOTAL_No_of_TRANSECTS[i];
    NT += TOTAL_No_of_TRANSECTS[i];
  }
  double * R_Presence    = (double *)calloc( No, sizeof(double) );
  double * R_Time_Vector = (double *)calloc( NT, sizeof(double) );
  
  n=0; 
  for(i=0; i<No_of_FILES; i++) 
    for(j=0; j<TOTAL_No_of_TRANSECTS[i]; j++) 
      R_Time_Vector[n++] = Time_Vector_Long[i][j];  
  n=0; 
  for(i=0; i<No_of_FILES; i++) 
    for(j=0; j<No_of_SITES[i]; j++)
      for(k=0; k<TOTAL_No_of_TRANSECTS[i]; k++)
	R_Presence[n++] = Presence[i][j][k];
  
  /* n=0;  */
  /* R_Species_Tag[0]='\0'; */
  /* for(i=0; i<No_of_FILES; i++) */
  /*   p = strcat (R_Species_Tag, Species_Tag[i]); */
  
  double * Results = (double *)calloc( No_of_FILES * 6, sizeof(double) );
  /*     E N D : -------------------------------------------------------
   */
  /* B E G I N : -------------------------------------------------------
     2. Transforming input arguments defining model parameters and 
     parameter space into R friendly pointers 
  */
  int * Index = (int *)calloc( MODEL_PARAMETERS_MAXIMUM, sizeof(int));
  Index[0] = I0; Index[1] = I1; Index[2] = I2; Index[3] = I3; 
  int * Discretization = (int *)calloc( MODEL_PARAMETERS_MAXIMUM, sizeof(int));
  Discretization[0]=d0; Discretization[1]=d1; Discretization[2]=d2; Discretization[3]=d3;
  double ** Par_Range = (double **)calloc( MODEL_PARAMETERS_MAXIMUM, sizeof(double *) );
  for(i=0; i<MODEL_PARAMETERS_MAXIMUM; i++) 
    Par_Range[i] = (double *)calloc( 2, sizeof(double) );
  Parameter_Model * MAX_P = (Parameter_Model *)calloc(1, sizeof(Parameter_Model) );
  Parameter_Model * min_P = (Parameter_Model *)calloc(1, sizeof(Parameter_Model) );
  Vector_Entry_into_Parameter_Model ( MAX_P0, Index[0], MAX_P );
  Vector_Entry_into_Parameter_Model ( MAX_P1, Index[1], MAX_P );
  Vector_Entry_into_Parameter_Model ( MAX_P2, Index[2], MAX_P );
  Vector_Entry_into_Parameter_Model ( MAX_P3, Index[3], MAX_P );
  Vector_Entry_into_Parameter_Model ( min_P0, Index[0], min_P );
  Vector_Entry_into_Parameter_Model ( min_P1, Index[1], min_P );
  Vector_Entry_into_Parameter_Model ( min_P2, Index[2], min_P );
  Vector_Entry_into_Parameter_Model ( min_P3, Index[3], min_P );

  int No_of_PARAMETERS = 4; 
  int No_of_PARAMETERS_MAX = MODEL_PARAMETERS_MAXIMUM; 
  printf(" Parameter Space Boundaries for heuristic searches:\n");
  printf(" Full potential dimension is %d: the colonization-extinction plane\n",
	 No_of_PARAMETERS_MAX);
  for(i=0; i<MODEL_PARAMETERS_MAXIMUM; i++) {
    int key = Index[i]; 
    Par_Range[i][1] = Parameter_Model_into_Vector_Entry (key, MAX_P);
    Par_Range[i][0] = Parameter_Model_into_Vector_Entry (key, min_P);
    printf(" ---> Parameter Key %d: [%s_0 = %g, %s_1 = %g]\n", 
	    i, Symbol[i], Par_Range[i][0], Symbol[i], Par_Range[i][1]);			
  }
  /*     E N D : -------------------------------------------------------
   */
  int Verbose, Minimization;
#if defined VERBOSE
  Verbose = 1;
#else 
  Verbose = 0;
#endif 
  Minimization = 1;
  
  double MISSING_VALUE_FLAG = 0.1;  
  MODEL_SELECTION_UPGMA_MacKENZIE_R_FUNCTION( &No_of_FILES, Species_Tag, 
					      R_Presence, No_of_SITES,
					      R_Time_Vector, TOTAL_No_of_TRANSECTS, 
					      &MISSING_VALUE_FLAG, 
					      &Colonization_Rate, Par_Range[0],  
					      &Extinction_Rate, Par_Range[1],
					      &Detectability_Value, Par_Range[2],
					      &Phi_0, Par_Range[3], 
					      &No_of_PARAMETERS, &No_of_PARAMETERS_MAX,
					      Index, Discretization, 
					      &TOLERANCE, &MAX_No_of_ITERATIONS, 
					      &Verbose, &Minimization, 
					      Results );
  
  FILE * fp = fopen("Model_Selection_Results.dat", "w");
  n=0;
  for(i=0; i<No_of_FILES; i++) { 
    for(j=0; j<6; j++) fprintf(fp, "%g\t", Results[n++] ); 
    fprintf(fp, "\n");
  }
  fclose(fp);
  
  /* B E G I N : -------------------------------------------------------
       Freeing up allocated memmory!!! 
    */
  free (Index); free (Discretization);
  for(i=0; i<MODEL_PARAMETERS_MAXIMUM; i++) free(Par_Range[i]);
  free (Par_Range);
  free(MAX_P); free(min_P); 
  free(Results); 

  for( i=0; i<No_of_FILES; i++ ){
    free(Time_Vector[i]);
    free(Time_Vector_Long[i]);
    free(Transects[i]);
    for (j=0; j<No_of_ROWS_MAX; j++) free( Presence[i][j] );
    free(Presence[i]); 
  }
  free( Presence ); free( Time_Vector); free( Time_Vector_Long); free(Transects); 
  free( No_of_SAMPLING_TIMES ); free(TOTAL_No_of_TRANSECTS); 
  free( No_of_SITES ); 
  
  for (i=0; i<No_of_FILES; i++) { free(Species_Tag[i]); free(File_Tag[i]); } 
  free(Species_Tag); free(File_Tag);

  for (i=0; i<No_of_ROWS_MAX; i++) free(Species_Name[i]); 
  free(Species_Name); 

  free(R_Presence); free(R_Time_Vector); //free(R_Species_Tag);
   #include <include.Parameter_Model.default.free.c>
  /*     E N D : -------------------------------------------------------
   */
  printf("\nEnd of progam\n");
  return(0);
}
  


