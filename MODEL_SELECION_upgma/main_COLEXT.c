/* 
   This code reads files from species presence/absence in the Pyrinees 
   lake system. A number of files (No_of_SPECIES) will be read. 

   The input matrix should have the folling estructure:

   Species Name  t_0   ... ... ... ... ... ... t_N
   sp1             1   0   0   1  
   ...           ...   ... ... ... ... ... ... ...

   Then, the code fits the simplest stochastic model underlying MacArthur and Wilson 
   IBT (1963) through maximum likelihood for each of the single files to be read. Each 
   file corresponds to a different taxonomic unit. Then, an UPWMA is used to classify 
   taxonomic units (p.e. species, Phyla, OUTs, etc) according to colonization/extinction
   values. Finally, at different levels of similarity on the colonization/extinction 
   parameter space, partitions, so different species groupings, are defined. Each 
   partition defines a different model with a different number of parameters. 
   Finally, Akaike Information Criteria are used for model comparison. 

   In an output file, NLL, AIC, AIC_c, AIC_d differences and AIC_w model weights are 
   organized in a table (each row corresponds to a model corresponding to a different 
   partition, this is, a different distribution of species into groups, and therefore, 
   a model with a different number of parameters). The code creates the file 
   Model_Selection_Results.dat to save these results. The table of results are also 
   saved in latex format. These files are generated by the function: 

   MODEL_SELECTION_UPGMA_R_FUNCTION(...) 
   
   which, in turn, calls:

   MODEL_SELECTION_UPGMA_DRIVER(...)

   which, in turn, calls two more functions which are in charge of doing all the 
   computationally-intensive work from the library: libda_IBT_Optimization.a:

   MODEL_SELECTION_UPGMA_R_SHLIB(...) 

   and 

   mle_Col_Ext_Uneven_Matrix_R_SHLIB(...)

   Essentially this main code is only written to wrap up the function:

   MODEL_SELECTION_UPGMA_R_FUNCTION(...)

   which is intended to be R callable when compiled as a shared object (see makefile).
   Notice that the compilation command below results in the shared object:
   
   MODEL_SELECTION_UPGMA_R_FUNCTION.so. 
   
   The challenge to adapt previous C code into R friendly functions is memmory 
   alignment since R function arguments are mandatory pointers to 1D single arrays. 
   Shared objects should be built to match this requirement in order to be called 
   by R through the native R function 
   
   ./C( [NAME_of_th_SHARED_OBJECT].so, arg1, arg2, ...). 
   
   A suitable R function wrapping this call is always recommendable. 

   The following paramaters are passed (as pointers) down to all these auxiliary 
   functions: 
   
   int * No_of_PARAMETERS,  int * No_of_PARAMETERS_MAX,
   int * Index, int * Discretization,
   double * Tolerance, int * No_of_ITERATIONS,
   int * Verbose, int * Minimization, 
   
   which will control different aspects of the underlying the optimization procedure. 

   Compilation:
   
   ~$ make TYPE_of_MAIN=COLEXT CPG=NON_CPGPLOT_REPRESENTATION RSH=R_SHLIB 

   Execution:

   ~$ ./upgma_model_selection_COLEXT -Nr 15 -Nc 17 -pC 1.0 -pE 1.0 -sP 2 -sT 1.0E-08 -m0 0.0 -M0 10.0 -m1 0.0 -M1 10.0

   Some relevant input arguments of the main program are:
   -Nr 15: Number of single data sets (corresponding to different files)
           For instance, differnt islands, different guilds, different
	   species. The initial hypothesis is that every data set
	   is best described by a different colonization-extinction
	   pair. 
   -Nc 17: Number max of columns (sampling times) associated to 
           the data sets (corresponding to different files).  
   -pC 1.0: Colonization initial guess in optimization searches.
   -m0 0.0 -M0 10.0: Min (m0) and Max (M0) parameters values 
                     for bounded optimization serches associated
		     to the first parameter (colonization)
   -pE 1.0: Extinction initial guess in optimization searches.
   -m1 0.0 -M1 10.0: Min (m1) and Max (M1) parameters values 
                     for bounded optimization serches associated
		     to the second parameter (extinction)
   -sP 2: Total Number of model parameters
   -sT 1.0E-08: Accuracy/tolerance value for heuristic optimization 
                searches.
   
   Remember that: 
   
   ~$ ./upgma_model_selection_COLEXT -h 

   will give you full information about model parameters. 

   See also /Include/include.Parameter_Model.argumentControl.c and 
   include.Parameter_Space.argumentControl.c and related include files
   in the /Include/ directory for full information.


   Valgrind execution:

   ~$ valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out.txt ./upgma_model_selection_COLEXT -Nr 15 -Nc 17 -pC 1.0 -pE 1.0 -sP 2 -sT 1.0E-08 -m0 0.0 -M0 10.0 -m1 0.0 -M1 10.0
*/

#include <MODEL.h>

#include <IO_Procedures_Pirineus.h>

#include "global.h"

#define VERBOSE

#define No_of_ROWS_MAX 500

void MODEL_SELECTION_UPGMA_R_FUNCTION( int * pNo_of_SPECIES, char ** Species_Tag, 
				       double * R_Presence, int * No_of_SITES, 
				       double * R_Time_Vector, int * No_of_TIMES, 
				       double * MISSING_VALUE_FLAG, 
				       double * Colonization_Rate, double * C_Range,
				       double * Extinction_Rate, double * E_Range, 
				       int * No_of_PARAMETERS,
				       int * No_of_PARAMETERS_MAX,
				       int * Index, 
				       int * Discretization,
				       double * Tolerance, 
				       int * No_of_ITERATIONS,
				       int * Verbose, 
				       int * Minimization,
				       double * R_Results ); 

int main(int argc, char **argv)
{
  int i,j,k,l,s,  n;
  Parameter_Model P;
  char * p;

  #include "default.c"

 /* Command line arguments */
  if(argc>1) ArgumentControl(argc,argv);
  // P_A_R_A_M_E_T_E_R___I_N_I_T_I_A_L_I_Z_A_T_I_O_N ( &P );
  P.No_of_SPECIES       = No_of_SPECIES;
  P.No_of_COLUMNS       = No_of_COLUMNS;
  P.No_of_TRANSECTS     = No_of_COLUMNS;
  P.Colonization_Rate   = Colonization_Rate;     /* Key 0 */
  P.Extinction_Rate     = Extinction_Rate;       /* Key 1 */
  P.Detectability_Value = 1.0;                   /* Key 2 */
  P.Phi_0               = 1.0;                   /* Key 3 */
  P.RATES               = 1;
   /* B E G I N :------------------------------------------------------
     1: Reading 'No_of_SPECIES' single data files. Since data files 
     may be very specific for each system, this part of the code 
     may not be made fully generic, but the output of this reading 
     procedure should result in No_of_SPECIES data matrices containing 
     Presence/Absence data and actual sampling times corresponding to each 
     file once missing values have been excluded. Missig values are 
     labeled with a flag (0.1, see IO_Missing_Value.c). Within a file, 
     sampling times may change from row to row.  
  */
  assert( No_of_SPECIES == 15 ); //-Nr 15
  assert( No_of_COLUMNS == 17 ); //-Nc 17
  
  char ** Species_Tag = (char **)calloc( No_of_SPECIES, sizeof(char *) );
  for (i=0; i<No_of_SPECIES; i++) Species_Tag[i] = (char *)calloc(100, sizeof(char) );
  zooplancton_Pirineus_Species_Tag_Creator_15SP( Species_Tag ) ;
 
  double *** Presence = (double ***)calloc(No_of_SPECIES, sizeof(double **));
  int * No_of_SAMPLING_TIMES = (int *)calloc(No_of_SPECIES, sizeof(int) );
  int * No_of_SITES = (int *)calloc(No_of_ROWS_MAX, sizeof(int) );
  double ** Time_Vector = (double **)calloc(No_of_SPECIES, sizeof(double *));

  for( i=0; i<No_of_SPECIES; i++ ){
    No_of_SAMPLING_TIMES[i] = No_of_COLUMNS; 
    Time_Vector[i] = (double *)calloc(No_of_SAMPLING_TIMES[i], sizeof(double));
    
    Presence[i] = (double **)calloc(No_of_ROWS_MAX, sizeof(double *));
    for (j=0; j<No_of_ROWS_MAX; j++)
      Presence[i][j] = (double *)calloc(No_of_SAMPLING_TIMES[i], sizeof(double ));
  }
  
  READ_FILES_ZOOPLANCTON_PIRINEUS ( No_of_SPECIES,  
				    Presence, No_of_SITES, 
				    Time_Vector, No_of_SAMPLING_TIMES );
  
  /* B E G I N : ------------------------------------------------------- 
     1. Transforming C arrys into R friendly arrays */
  int No, NT;
  No  = 0;  
  for(i=0; i<No_of_SPECIES; i++) { 
    No += No_of_SITES[i] * No_of_COLUMNS;
  }
  NT  = No_of_SPECIES * No_of_COLUMNS;
  double * R_Presence    = (double *)calloc( No, sizeof(double) );
  double * R_Time_Vector = (double *)calloc( NT, sizeof(double) );
  
  n=0; 
  for(i=0; i<No_of_SPECIES; i++) 
    for(j=0; j<No_of_SAMPLING_TIMES[i]; j++) 
      R_Time_Vector[n++] = Time_Vector[i][j];  
  n=0; 
  for(i=0; i<No_of_SPECIES; i++) 
    for(j=0; j<No_of_SITES[i]; j++)
      for(k=0; k<No_of_SAMPLING_TIMES[i]; k++)
	R_Presence[n++] = Presence[i][j][k];

  /* n=0;  */
  /* R_Species_Tag[0]='\0'; */
  /* for(i=0; i<No_of_SPECIES; i++) */
  /*   p = strcat (R_Species_Tag, Species_Tag[i]); */
  
  double * Results = (double *)calloc( No_of_SPECIES * 6, sizeof(double) );
  /*     E N D : -------------------------------------------------------
   */
  /* B E G I N : -------------------------------------------------------
     2. Transforming input arguments defining model parameters and 
     parameter space into R friendly pointers 
  */
  int * Index = (int *)calloc( MODEL_PARAMETERS_MAXIMUM, sizeof(int));
  Index[0] = I0; Index[1] = I1; Index[2] = I2; Index[3] = I3; 
  int * Discretization = (int *)calloc( MODEL_PARAMETERS_MAXIMUM, sizeof(int));
  Discretization[0]=d0; Discretization[1]=d1; Discretization[2]=d2; Discretization[3]=d3;
  double ** Par_Range = (double **)calloc( MODEL_PARAMETERS_MAXIMUM, sizeof(double *) );
  for(i=0; i<MODEL_PARAMETERS_MAXIMUM; i++) 
    Par_Range[i] = (double *)calloc( 2, sizeof(double) );
  Parameter_Model * MAX_P = (Parameter_Model *)calloc(1, sizeof(Parameter_Model) );
  Parameter_Model * min_P = (Parameter_Model *)calloc(1, sizeof(Parameter_Model) );
  Vector_Entry_into_Parameter_Model ( MAX_P0, Index[0], MAX_P );
  Vector_Entry_into_Parameter_Model ( MAX_P1, Index[1], MAX_P );
  Vector_Entry_into_Parameter_Model ( min_P0, Index[0], min_P );
  Vector_Entry_into_Parameter_Model ( min_P1, Index[1], min_P );

  printf(" Parameter Space Boundaries for heuristic searches:\n");
  printf(" Full potential dimension is 2: the colonization-extinction plane\n");
  for(i=0; i<2; i++) {
    int key = Index[i]; 
    Par_Range[i][1] = Parameter_Model_into_Vector_Entry (key, MAX_P);
    Par_Range[i][0] = Parameter_Model_into_Vector_Entry (key, min_P);
    printf(" ---> Parameter Key %d: [%s_0 = %g, %s_1 = %g]\n", 
	    i, Symbol[i], Par_Range[i][0], Symbol[i], Par_Range[i][1]);			
  }
  /*     E N D : -------------------------------------------------------
   */
  int Verbose, Minimization;
#if defined VERBOSE
  Verbose = 1;
#else 
  Verbose = 0;
#endif 
  Minimization = 1;
  int No_of_PARAMETERS = 2; 
  int No_of_PARAMETERS_MAX = 2; 
  double MISSING_VALUE_FLAG = 0.1;  
  MODEL_SELECTION_UPGMA_R_FUNCTION( &No_of_SPECIES, Species_Tag, 
  				    R_Presence, No_of_SITES,
  				    R_Time_Vector, No_of_SAMPLING_TIMES, 
				    &MISSING_VALUE_FLAG, 
				    &Colonization_Rate, Par_Range[0],  
				    &Extinction_Rate, Par_Range[1], 
				    &No_of_PARAMETERS, &No_of_PARAMETERS_MAX,
				    Index, Discretization, 
				    &TOLERANCE, &MAX_No_of_ITERATIONS, 
				    &Verbose, &Minimization, 
				    Results );
  FILE * fp = fopen("Model_Selection_Results.dat", "w");
  n=0;
  for(i=0; i<No_of_SPECIES; i++) { 
    for(j=0; j<6; j++) fprintf(fp, "%g\t", Results[n++] ); 
    fprintf(fp, "\n");
  }
  fclose(fp);
  
  /* B E G I N : -------------------------------------------------------
       Freeing up allocated memmory!!! 
    */
  free (Index); free (Discretization);
  for(i=0; i<MODEL_PARAMETERS_MAXIMUM; i++) free(Par_Range[i]);
  free (Par_Range);
  free(MAX_P); free(min_P); 
  free(Results); 

  for( i=0; i<No_of_SPECIES; i++ ){
    free(Time_Vector[i]);
    for (j=0; j<No_of_ROWS_MAX; j++) free( Presence[i][j] );
    free(Presence[i]); 
  }
  free( Presence ); free( Time_Vector); 
  free( No_of_SAMPLING_TIMES );
  free( No_of_SITES ); 
  
  for (i=0; i<No_of_SPECIES; i++) free(Species_Tag[i]);
  free(Species_Tag);

  free(R_Presence); free(R_Time_Vector); //free(R_Species_Tag);
  #include <include.Parameter_Model.default.free.c>
  /*     E N D : -------------------------------------------------------
   */
  printf("\nEnd of progam\n");
  return(0);
}
  


